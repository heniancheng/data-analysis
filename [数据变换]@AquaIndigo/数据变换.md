# 数据变换和一些其他非监督模型

几个非监督模型可用于通常的数据变换，例如 one-hot 编码，在`MLJ`中是可用的。

`MLJ`的变换器（transformer）如果没有学习参数，则是*静态*的，这样的转换器相当于一个普通的函数。认识到这是个静态的`MLJ`变换器是有帮助的，尤其是在函数依赖用户控制的一些参数（模型中的超参数）。

一些非监督模型，例如聚类算法，除了`transform`方法外还具有`predict`方法，在[可预测的转换器](##可预测的转换器)中会有一些例子。

最后注意调整一个分布、或更广泛的样本到一些数据的模型是有监督的模型，虽然有时把它们看做无监督模型。[Models that learn a probability](https://alan-turing-institute.github.io/MLJ.jl/stable/adding_models_for_general_use/#Models-that-learn-a-probability-distribution-1)中有一些例子。

前提知识：[科学类型](https://alan-turing-institute.github.io/MLJScientificTypes.jl/dev/)

```julia
Finite{N}
├─ Multiclass{N}
└─ OrderedFactor{N}

Infinite
├─ Continuous
└─ Count

Image{W,H}
├─ ColorImage{W,H}
└─ GrayImage{W,H}

ScientificTimeType
├─ ScientificDate
├─ ScientificTime
└─ ScientificDateTime
```



## 内置转换器

#### `MLJModels.UnivariateStandardizer` 

将单变量（向量）标准化，效果相当于计算
$$
\frac{x - \bar x}{Var(x)}
$$
用法

```julia
julia> using MLJModels, Statistics, MLJ

julia> ustandr = UnivariateStandardizer();

julia> x = rand(10);

julia> usdMC = machine(ustandr, x)
Machine{UnivariateStandardizer} @ 5…94


julia> fit!(usdMC);
[ Info: Training Machine{UnivariateStandardizer} @ 5…94.

julia> xsd = transform(usdMC, x);

julia> xsd == (x .- mean(x)) ./ std(x)
true
    
    
julia> xsd == transform(fit!(machine(UnivariateStandardizer(), x)), x); # 简写
[ Info: Training Machine{UnivariateStandardizer} @ 1…19.
true
    
```

 

#### `MLJModels.Standardizer`

`Standardizer(; features=Symbol[], ignore=false, ordered_factor=false, count=false)`

用来标准化表格状数据的每一列的非监督模型，如果不指定`features`，每个元素的scitype为`Continuous`（例如浮点数）的列均会被标准化；否则，如果`ignore=false`，在`features`中`Continuous` 的那些列将会被转换，`ignore=true`，没有被选中的那些features将会被标准化。若要支持`Count`（如`Int`类型）或者 `OrderedFactor`类型的转换，则需将相应的最后两个标识设置为`true`。

`features`除了接收表示特征的向量，还能接收返回布尔值可调用对象，例如`Standardizer(features = name -> name in [:x1, :x3], ignore = true, count=true)` 和 `Standardizer(features = [:x1, :x3], ignore = true, count=true)`效果是一样的，意味着标准化所有除了`:x1`或`:x3`中`Continuous`  和 `Count`特征。

Examples:

```julia
julia> using MLJModels, CategoricalArrays, MLJBase

julia> X = (ordinal1 = [1, 2, 3],
            ordinal2 = categorical([:x, :y, :x], ordered=true),
            ordinal3 = [10.0, 20.0, 30.0],
            ordinal4 = [-20.0, -30.0, -40.0],
            nominal = categorical(["Your father", "he", "is"]));#命名元组

julia> stand1 = Standardizer();

julia> transform(fit!(machine(stand1, X)), X)
[ Info: Training Machine{Standardizer} @ 7…97.
(ordinal1 = [1, 2, 3],
 ordinal2 = CategoricalValue{Symbol,UInt32}[:x, :y, :x],
 ordinal3 = [-1.0, 0.0, 1.0],
 ordinal4 = [1.0, 0.0, -1.0],
 nominal = CategoricalVale{String,UInt32}["Your father", "he", "is"],)

julia> stand2 = Standardizer(features=[:ordinal3, ], ignore=true, count=true);#:ordinal3 不被标准化

julia> transform(fit!(machine(stand2, X)), X) 
[ Info: Training Machine{Standardizer} @ 1…87.
(ordinal1 = [-1.0, 0.0, 1.0],
 ordinal2 = CategoricalValue{Symbol,UInt32}[:x, :y, :x],
 ordinal3 = [10.0, 20.0, 30.0],
 ordinal4 = [1.0, 0.0, -1.0],
 nominal = CategoricalValue{String,UInt32}["Your father", "he", "is"],)
        
julia> X = DataFrame(X);

julia> transform(fit!(machine(stand1, X)), X) #Count (Int)没有被标准化
[ Info: Training Machine{Standardizer} @ 1…66.
3×5 DataFrame
│ Row │ ordinal1 │ ordinal2 │ ordinal3 │ ordinal4 │ nominal     │
│     │ Int64    │ Cat…     │ Float64  │ Float64  │ Cat…        │
├─────┼──────────┼──────────┼──────────┼──────────┼─────────────┤
│ 1   │ 1        │ :x       │ -1.0     │ 1.0      │ Your father │
│ 2   │ 2        │ :y       │ 0.0      │ 0.0      │ he          │
│ 3   │ 3        │ :x       │ 1.0      │ -1.0     │ is          │

julia> transform(fit!(machine(Standardizer(count=true), X)), X)
[ Info: Training Machine{Standardizer} @ 1…24.
3×5 DataFrame
│ Row │ ordinal1 │ ordinal2 │ ordinal3 │ ordinal4 │ nominal     │
│     │ Float64  │ Cat…     │ Float64  │ Float64  │ Cat…        │
├─────┼──────────┼──────────┼──────────┼──────────┼─────────────┤
│ 1   │ -1.0     │ :x       │ -1.0     │ 1.0      │ Your father │
│ 2   │ 0.0      │ :y       │ 0.0      │ 0.0      │ he          │
│ 3   │ 1.0      │ :x       │ 1.0      │ -1.0     │ is          │
```



#### `MLJModels.OneHotEncoder`

```julia
OneHotEncoder(; features=Symbol[],
                ignore=false,
                ordered_factor=true,
                drop_last=false)
```

对`Finite`特征进行 one-hot （一位有效）编码。参数`features`与`ignore`的作用与上文类似。	

若`ordered_factor=false`，上述对 `Finite` 的规则改为对 `Multiclass`成立，即对 `OrderedFactor`不会进行转换。

若指定`drop_last=true`，每个特征的最后一个等级的列会被丢弃。

Examples:

```julia
X = (name=categorical(["Danesh", "Lee", "Mary", "John"]),
     grade=categorical([:A, :B, :A, :C], ordered=true),
     height=[1.85, 1.67, 1.5, 1.67],
     n_devices=[3, 2, 4, 3])
schema(X)

┌───────────┬─────────────────────────────────┬──────────────────┐
│ _.names   │ _.types                         │ _.scitypes       │
├───────────┼─────────────────────────────────┼──────────────────┤
│ name      │ CategoricalValue{String,UInt32} │ Multiclass{4}    │
│ grade     │ CategoricalValue{Symbol,UInt32} │ OrderedFactor{3} │
│ height    │ Float64                         │ Continuous       │
│ n_devices │ Int64                           │ Count            │
└───────────┴─────────────────────────────────┴──────────────────┘
_.nrows = 4

hot = OneHotEncoder(ordered_factor=true); #name and grade will both be transformed
mach = fit!(machine(hot, X))
transform(mach, X) |> schema

┌──────────────┬─────────┬────────────┐
│ _.names      │ _.types │ _.scitypes │
├──────────────┼─────────┼────────────┤
│ name__Danesh │ Float64 │ Continuous │
│ name__John   │ Float64 │ Continuous │
│ name__Lee    │ Float64 │ Continuous │
│ name__Mary   │ Float64 │ Continuous │
│ grade__A     │ Float64 │ Continuous │
│ grade__B     │ Float64 │ Continuous │
│ grade__C     │ Float64 │ Continuous │
│ height       │ Float64 │ Continuous │
│ n_devices    │ Int64   │ Count      │
└──────────────┴─────────┴────────────┘
_.nrows = 4
```



#### `MLJModels.ContinuousEncoder`





## 预测的转换器

